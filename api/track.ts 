import type { VercelRequest, VercelResponse } from '@vercel/node';

// Kafka integration
let kafka: any = null;
let producer: any = null;
let isConnected = false;

async function getKafkaProducer() {
  if (!kafka) {
    try {
      // Dynamic import to avoid issues with serverless
      const { Kafka, Partitioners } = await import('kafkajs');
      
      kafka = new Kafka({
        clientId: "vercel-tracking",
        brokers: [process.env.KAFKA_BROKER!],
        ssl: true,
        sasl: {
          mechanism: "plain",
          username: process.env.KAFKA_KEY!,
          password: process.env.KAFKA_SECRET!,
        },
        connectionTimeout: 10000,
        authenticationTimeout: 10000,
        retry: {
          initialRetryTime: 100,
          retries: 3,
        },
      });

      producer = kafka.producer({
        createPartitioner: Partitioners.LegacyPartitioner,
        maxInFlightRequests: 1,
        idempotent: false,
      });
    } catch (error) {
      console.error("‚ùå Kafka setup failed:", error);
      return { producer: null, isConnected: false };
    }
  }

  if (!isConnected && producer) {
    try {
      await producer.connect();
      isConnected = true;
      console.log("‚úÖ Kafka connected");
    } catch (error) {
      console.error("‚ùå Kafka connection failed:", error);
      isConnected = false;
    }
  }

  return { producer, isConnected };
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // Handle preflight OPTIONS request
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get client IP
    const clientIP = 
      (req.headers['x-forwarded-for'] as string)?.split(',')[0] ||
      req.headers['x-real-ip'] as string ||
      req.connection?.remoteAddress ||
      'unknown';

    // Create tracking event
    const trackingEvent = {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      ip: clientIP,
      url: req.body.url || '',
      referrer: req.body.referrer || '',
      user_agent: req.body.user_agent || '',
      host: req.body.host || '',
      event_type: req.body.event_type || 'unknown',
      event_data: {
        element: req.body.element,
        text: req.body.text,
        scroll_depth: req.body.scroll_depth,
        time_on_page: req.body.time_on_page,
      },
      headers: req.headers,
    };

    console.log("üìä Tracking Event Created:", trackingEvent);

    // Try to send to Kafka
    let kafkaSent = false;
    try {
      const { producer, isConnected } = await getKafkaProducer();
      
      if (isConnected && producer) {
        await producer.send({
          topic: process.env.KAFKA_TOPIC || "sibi_web_events_store",
          messages: [{ value: JSON.stringify(trackingEvent) }],
        });
        kafkaSent = true;
        console.log("üì© Event sent to Kafka successfully");
      } else {
        console.log("‚ö†Ô∏è Kafka not connected, event logged only");
      }
    } catch (kafkaError) {
      console.error("‚ùå Kafka send failed:", kafkaError);
      // Continue anyway - don't fail the request
    }

    // Always return success
    res.status(200).json({
      success: true,
      eventId: trackingEvent.id,
      message: "Event tracked successfully",
      kafka_sent: kafkaSent,
    });

  } catch (error) {
    console.error("‚ùå Tracking error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to process tracking event",
    });
  }
}

// ================================
// OPTIONAL: vercel.json
// ================================
// Create this file in your project root if you need custom config:
/*
{
  "functions": {
    "api/track.ts": {
      "maxDuration": 30
    }
  },
  "env": {
    "KAFKA_BROKER": "@kafka-broker",
    "KAFKA_KEY": "@kafka-key", 
    "KAFKA_SECRET": "@kafka-secret",
    "KAFKA_TOPIC": "@kafka-topic"
  }
}
*/
