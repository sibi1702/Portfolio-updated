// api/track.ts (Create this file in root/api/ folder)
import type { VercelRequest, VercelResponse } from '@vercel/node';

// Kafka integration
let kafka: any = null;
let producer: any = null;
let isConnected = false;

async function getKafkaProducer() {
  if (!kafka) {
    // Dynamic import to avoid issues with serverless
    const { Kafka, Partitioners } = await import('kafkajs');
    
    kafka = new Kafka({
      clientId: "vercel-tracking",
      brokers: [process.env.KAFKA_BROKER!],
      ssl: true,
      sasl: {
        mechanism: "plain",
        username: process.env.KAFKA_KEY!,
        password: process.env.KAFKA_SECRET!,
      },
      connectionTimeout: 10000,
      authenticationTimeout: 10000,
      retry: {
        initialRetryTime: 100,
        retries: 3,
      },
    });

    producer = kafka.producer({
      createPartitioner: Partitioners.LegacyPartitioner,
      maxInFlightRequests: 1,
      idempotent: false,
    });
  }

  if (!isConnected) {
    try {
      await producer.connect();
      isConnected = true;
      console.log("‚úÖ Kafka connected");
    } catch (error) {
      console.error("‚ùå Kafka connection failed:", error);
      isConnected = false;
    }
  }

  return { producer, isConnected };
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // Handle preflight OPTIONS request
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get client IP
    const clientIP = 
      (req.headers['x-forwarded-for'] as string)?.split(',')[0] ||
      req.headers['x-real-ip'] as string ||
      'unknown';

    // Create tracking event with same structure as Railway
    const trackingEvent = {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      ip: clientIP,
      url: req.body.url,
      referrer: req.body.referrer,
      user_agent: req.body.user_agent,
      host: req.body.host,
      event_type: req.body.event_type,
      event_data: {
        element: req.body.element,
        text: req.body.text,
        scroll_depth: req.body.scroll_depth,
        time_on_page: req.body.time_on_page,
      },
      headers: req.body.headers,
    };

    console.log("üìä Tracking Event Created:", trackingEvent);

    // Try to send to Kafka
    const { producer, isConnected } = await getKafkaProducer();
    
    if (isConnected && producer) {
      try {
        await producer.send({
          topic: process.env.KAFKA_TOPIC || "sibi_web_events_store",
          messages: [{ value: JSON.stringify(trackingEvent) }],
        });
        console.log("üì© Event sent to Kafka successfully");
      } catch (kafkaError) {
        console.error("‚ùå Kafka send failed:", kafkaError);
        // Continue anyway - don't fail the request
      }
    } else {
      console.log("‚ö†Ô∏è Kafka not connected, event logged only");
    }

    // Always return success
    res.status(200).json({
      success: true,
      eventId: trackingEvent.id,
      message: "Event tracked successfully",
      kafka_sent: isConnected,
    });

  } catch (error) {
    console.error("‚ùå Tracking error:", error);
    res.status(400).json({
      success: false,
      error: "Failed to process tracking event",
    });
  }
}